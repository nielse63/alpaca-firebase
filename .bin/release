#!/usr/bin/env node
const fs = require('fs-extra');
const fg = require('fast-glob');
const path = require('path');
const dependencyTree = require('dependency-tree');
const { spawnSync } = require('child_process');

const root = path.resolve(__dirname, '..');
let dependenciesMap = {};

const getEntryFiles = async () => {
  const files = await fg('packages/*/package.json');
  const output = await Promise.all(
    files.map(async (file) => {
      const {
        name,
        version,
        dependencies = {},
      } = await fs.readJson(path.resolve(root, file));
      return {
        dir: path.dirname(file),
        version,
        name,
        dependencies: Object.keys(dependencies).filter((dep) => {
          return dep.startsWith('@alpaca-firebase/');
        }),
      };
    })
  );
  return output;
};

const deps = async () => {
  const releasedPackages = new Set();
  const files = await getEntryFiles();
  const sortedPackages = files.sort((a, b) => {
    return a.dependencies.length - b.dependencies.length;
  });
  for (const pkg of sortedPackages) {
    pkg.dependencies.forEach((dep) => {
      if (!releasedPackages.has(dep)) {
        console.error(
          `${dep} is not released yet (required by ${pkg.name}). exiting...`
        );
        process.exit(1);
      }
    });

    console.log(`releasing ${pkg.name}`);
    const result = spawnSync(
      'npx',
      [
        'release-it',
        '--increment=patch',
        '--no-git',
        '--npm.publish=true',
        '--github.release=false',
        '--npm.publishArgs=--access=public',
        '--ci',
      ],
      {
        cwd: path.resolve(root, pkg.dir),
        stdio: 'inherit',
      }
    );

    if (result.error) {
      console.error(result.error);
      process.exit(1);
    }

    if (result.status !== 0) {
      console.error('Build failed');
      process.exit(1);
    }
    releasedPackages.add(pkg.name);
  }
  // console.log(sortedPackages);
  // files.forEach((file) => {
  //   const pkgName = '@alpaca-firebase/' + file.split('/')[1];
  //   dependenciesMap[pkgName] = 0;
  // });
  // files.forEach(readDependencies);
  // const sortedDependencies = Object.keys(dependenciesMap).sort(
  //   (a, b) => dependenciesMap[b] - dependenciesMap[a]
  // );
  // const packagePaths = sortedDependencies.map((dep) => {
  //   return `./packages/${dep.split('/')[1]}`;
  // });
  // const pkg = await fs.readJson(path.resolve(root, 'package.json'));
  // pkg.workspaces = [...packagePaths, './functions'];
  // await fs.writeJson(path.resolve(root, 'package.json'), pkg, {
  //   spaces: 2,
  // });
};

deps().catch(console.error);
